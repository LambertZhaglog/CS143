SPIM Version 6.5 of January 4, 2003
Copyright 1990-2003 by James R. Larus (larus@cs.wisc.edu).
All Rights Reserved.
See the file README for a full copyright notice.
Loaded: /usr/class/cs143/cool/lib/trap.handler
\x.x
\x.\y.x
\x.\y.\z.((((x)@(z)))@(((y)@(z))))
beta-reduce: ((((((\x.\y.\z.((((x)@(z)))@(((y)@(z)))))@(\x.\y.x)))@(\x.x)))@(\x.x)) =>
((((((\x.\y.\z.((((x)@(z)))@(((y)@(z)))))@(\x.\y.x)))@(\x.x)))@(\x.x))
beta-reduce: ((((\x.\y.x)@(\x.x)))@(\x.x)) =>
((((\x.\y.x)@(\x.x)))@(\x.x))
Generating code for ((\x.x)@(\x.x))
------------------cut here------------------
(*Generated by lam.cl (Jeff Foster, March 2000)*)
class EvalObject inherits IO {
  eval() : EvalObject { { abort(); self; } };
};
class Closure inherits EvalObject {
  parent : Closure;
  x : EvalObject;
  get_parent() : Closure { parent };
  get_x() : EvalObject { x };
  init(p : Closure) : Closure {{ parent <- p; self; }};
  apply(y : EvalObject) : EvalObject { { abort(); self; } };
};
class Main {
  main() : EvalObject {
(let x : EvalObject <- ((new Closure0).init(new Closure)),
     y : EvalObject <- ((new Closure1).init(new Closure)) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac)
};
};
class Closure1 inherits Closure {
  apply(y : EvalObject) : EvalObject {
    { out_string("Applying closure 1\n");
      x <- y;
get_x();}};
};
------------------cut here------------------
Generating code for ((((((\x.\y.\z.((((x)@(z)))@(((y)@(z)))))@(\x.\y.x)))@(\x.x)))@(\x.x))
------------------cut here------------------
(*Generated by lam.cl (Jeff Foster, March 2000)*)
class EvalObject inherits IO {
  eval() : EvalObject { { abort(); self; } };
};
class Closure inherits EvalObject {
  parent : Closure;
  x : EvalObject;
  get_parent() : Closure { parent };
  get_x() : EvalObject { x };
  init(p : Closure) : Closure {{ parent <- p; self; }};
  apply(y : EvalObject) : EvalObject { { abort(); self; } };
};
class Main {
  main() : EvalObject {
(let x : EvalObject <- (let x : EvalObject <- (let x : EvalObject <- ((new Closure0).init(new Closure)),
     y : EvalObject <- ((new Closure1).init(new Closure)) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac),
     y : EvalObject <- ((new Closure2).init(new Closure)) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac),
     y : EvalObject <- ((new Closure3).init(new Closure)) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac)
};
};
class Closure3 inherits Closure {
  apply(y : EvalObject) : EvalObject {
    { out_string("Applying closure 3\n");
      x <- y;
get_x();}};
};
------------------cut here------------------
Generating code for ((((((((((((((((\x.x)@(\x.\y.x)))@(\x.\y.\z.((((x)@(z)))@(((y)@(z)))))))@(\x.\y.\z.((((x)@(z)))@(((y)@(z)))))))@(\x.\y.x)))@(\x.\y.\z.((((x)@(z)))@(((y)@(z)))))))@(\x.x)))@(\x.\y.x)))@(\x.x))
------------------cut here------------------
(*Generated by lam.cl (Jeff Foster, March 2000)*)
class EvalObject inherits IO {
  eval() : EvalObject { { abort(); self; } };
};
class Closure inherits EvalObject {
  parent : Closure;
  x : EvalObject;
  get_parent() : Closure { parent };
  get_x() : EvalObject { x };
  init(p : Closure) : Closure {{ parent <- p; self; }};
  apply(y : EvalObject) : EvalObject { { abort(); self; } };
};
class Main {
  main() : EvalObject {
(let x : EvalObject <- (let x : EvalObject <- (let x : EvalObject <- (let x : EvalObject <- (let x : EvalObject <- (let x : EvalObject <- (let x : EvalObject <- (let x : EvalObject <- ((new Closure0).init(new Closure)),
     y : EvalObject <- ((new Closure1).init(new Closure)) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac),
     y : EvalObject <- ((new Closure2).init(new Closure)) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac),
     y : EvalObject <- ((new Closure3).init(new Closure)) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac),
     y : EvalObject <- ((new Closure4).init(new Closure)) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac),
     y : EvalObject <- ((new Closure5).init(new Closure)) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac),
     y : EvalObject <- ((new Closure6).init(new Closure)) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac),
     y : EvalObject <- ((new Closure7).init(new Closure)) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac),
     y : EvalObject <- ((new Closure8).init(new Closure)) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac)
};
};
class Closure8 inherits Closure {
  apply(y : EvalObject) : EvalObject {
    { out_string("Applying closure 8\n");
      x <- y;
get_x();}};
};
------------------cut here------------------
Generating code for ((((\x.x)@(((\x.\y.x)@(\x.\y.\z.((((x)@(z)))@(((y)@(z)))))))))@(((\x.\y.x)@(((\x.\y.\z.((((x)@(z)))@(((y)@(z)))))@(\x.\y.\z.((((x)@(z)))@(((y)@(z))))))))))
------------------cut here------------------
(*Generated by lam.cl (Jeff Foster, March 2000)*)
class EvalObject inherits IO {
  eval() : EvalObject { { abort(); self; } };
};
class Closure inherits EvalObject {
  parent : Closure;
  x : EvalObject;
  get_parent() : Closure { parent };
  get_x() : EvalObject { x };
  init(p : Closure) : Closure {{ parent <- p; self; }};
  apply(y : EvalObject) : EvalObject { { abort(); self; } };
};
class Main {
  main() : EvalObject {
(let x : EvalObject <- (let x : EvalObject <- ((new Closure0).init(new Closure)),
     y : EvalObject <- (let x : EvalObject <- ((new Closure1).init(new Closure)),
     y : EvalObject <- ((new Closure2).init(new Closure)) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac),
     y : EvalObject <- (let x : EvalObject <- ((new Closure3).init(new Closure)),
     y : EvalObject <- (let x : EvalObject <- ((new Closure4).init(new Closure)),
     y : EvalObject <- ((new Closure5).init(new Closure)) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac) in
  case x of
    c : Closure => c.apply(y);
    o : Object => { abort(); new EvalObject; };
  esac)
};
};
class Closure5 inherits Closure {
  apply(y : EvalObject) : EvalObject {
    { out_string("Applying closure 5\n");
      x <- y;
((new Closure6).init(self));}};
};
------------------cut here------------------
COOL program successfully executed
